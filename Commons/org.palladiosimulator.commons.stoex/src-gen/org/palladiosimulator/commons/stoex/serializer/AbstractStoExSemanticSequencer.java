/*
 * generated by Xtext
 */
package org.palladiosimulator.commons.stoex.serializer;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.palladiosimulator.commons.stoex.services.StoExGrammarAccess;

import com.google.inject.Inject;

import de.uka.ipd.sdq.probfunction.BoolSample;
import de.uka.ipd.sdq.probfunction.BoxedPDF;
import de.uka.ipd.sdq.probfunction.ContinuousSample;
import de.uka.ipd.sdq.probfunction.DoubleSample;
import de.uka.ipd.sdq.probfunction.IntSample;
import de.uka.ipd.sdq.probfunction.ProbabilityMassFunction;
import de.uka.ipd.sdq.probfunction.ProbfunctionPackage;
import de.uka.ipd.sdq.probfunction.StringSample;
import de.uka.ipd.sdq.stoex.BoolLiteral;
import de.uka.ipd.sdq.stoex.BooleanOperatorExpression;
import de.uka.ipd.sdq.stoex.CompareExpression;
import de.uka.ipd.sdq.stoex.DoubleLiteral;
import de.uka.ipd.sdq.stoex.FunctionLiteral;
import de.uka.ipd.sdq.stoex.IfElseExpression;
import de.uka.ipd.sdq.stoex.IntLiteral;
import de.uka.ipd.sdq.stoex.NamespaceReference;
import de.uka.ipd.sdq.stoex.NegativeExpression;
import de.uka.ipd.sdq.stoex.NotExpression;
import de.uka.ipd.sdq.stoex.Parenthesis;
import de.uka.ipd.sdq.stoex.PowerExpression;
import de.uka.ipd.sdq.stoex.ProbabilityFunctionLiteral;
import de.uka.ipd.sdq.stoex.ProductExpression;
import de.uka.ipd.sdq.stoex.StoexPackage;
import de.uka.ipd.sdq.stoex.StringLiteral;
import de.uka.ipd.sdq.stoex.TermExpression;
import de.uka.ipd.sdq.stoex.Variable;
import de.uka.ipd.sdq.stoex.VariableReference;
import de.uka.ipd.sdq.units.BaseUnit;
import de.uka.ipd.sdq.units.UnitDivision;
import de.uka.ipd.sdq.units.UnitMultiplication;
import de.uka.ipd.sdq.units.UnitPower;
import de.uka.ipd.sdq.units.UnitsPackage;

@SuppressWarnings("all")
public abstract class AbstractStoExSemanticSequencer extends AbstractDelegatingSemanticSequencer {

    @Inject
    private StoExGrammarAccess grammarAccess;

    public void createSequence(EObject context, EObject semanticObject) {
        if (semanticObject.eClass().getEPackage() == ProbfunctionPackage.eINSTANCE)
            switch (semanticObject.eClass().getClassifierID()) {
            case ProbfunctionPackage.BOOL_SAMPLE:
                sequence_boolsample(context, (BoolSample) semanticObject);
                return;
            case ProbfunctionPackage.BOXED_PDF:
                sequence_BoxedPDF(context, (BoxedPDF) semanticObject);
                return;
            case ProbfunctionPackage.CONTINUOUS_SAMPLE:
                sequence_real_pdf_sample(context, (ContinuousSample) semanticObject);
                return;
            case ProbfunctionPackage.DOUBLE_SAMPLE:
                sequence_numeric_real_sample(context, (DoubleSample) semanticObject);
                return;
            case ProbfunctionPackage.INT_SAMPLE:
                sequence_numeric_int_sample(context, (IntSample) semanticObject);
                return;
            case ProbfunctionPackage.PROBABILITY_MASS_FUNCTION:
                sequence_ProbabilityMassFunction(context, (ProbabilityMassFunction) semanticObject);
                return;
            case ProbfunctionPackage.STRING_SAMPLE:
                sequence_stringsample(context, (StringSample) semanticObject);
                return;
            }
        else if (semanticObject.eClass().getEPackage() == StoexPackage.eINSTANCE)
            switch (semanticObject.eClass().getClassifierID()) {
            case StoexPackage.BOOL_LITERAL:
                sequence_BoolLiteral(context, (BoolLiteral) semanticObject);
                return;
            case StoexPackage.BOOLEAN_OPERATOR_EXPRESSION:
                if (context == grammarAccess.getBooleanExpressionRule()
                        || context == grammarAccess.getBooleanExpressionAccess()
                                .getBooleanOperatorExpressionLeftAction_1_0()) {
                    sequence_BooleanExpression_boolOrExpr(context, (BooleanOperatorExpression) semanticObject);
                    return;
                } else if (context == grammarAccess.getBoolAndExprRule()
                        || context == grammarAccess.getBoolAndExprAccess().getBooleanOperatorExpressionLeftAction_1_0()
                        || context == grammarAccess.getExpressionRule()
                        || context == grammarAccess.getIfelseExprRule()
                        || context == grammarAccess.getIfelseExprAccess()
                                .getIfElseExpressionConditionExpressionAction_1_0()) {
                    sequence_boolAndExpr_boolOrExpr(context, (BooleanOperatorExpression) semanticObject);
                    return;
                } else if (context == grammarAccess.getBoolOrExprRule()
                        || context == grammarAccess.getBoolOrExprAccess().getBooleanOperatorExpressionLeftAction_1_0()) {
                    sequence_boolOrExpr(context, (BooleanOperatorExpression) semanticObject);
                    return;
                } else
                    break;
            case StoexPackage.COMPARE_EXPRESSION:
                sequence_compareExpr(context, (CompareExpression) semanticObject);
                return;
            case StoexPackage.DOUBLE_LITERAL:
                sequence_DoubleLiteral(context, (DoubleLiteral) semanticObject);
                return;
            case StoexPackage.FUNCTION_LITERAL:
                sequence_FunctionLiteral(context, (FunctionLiteral) semanticObject);
                return;
            case StoexPackage.IF_ELSE_EXPRESSION:
                sequence_ifelseExpr(context, (IfElseExpression) semanticObject);
                return;
            case StoexPackage.INT_LITERAL:
                sequence_IntLiteral(context, (IntLiteral) semanticObject);
                return;
            case StoexPackage.NAMESPACE_REFERENCE:
                sequence_NamespaceReference(context, (NamespaceReference) semanticObject);
                return;
            case StoexPackage.NEGATIVE_EXPRESSION:
                sequence_NegativeExpression(context, (NegativeExpression) semanticObject);
                return;
            case StoexPackage.NOT_EXPRESSION:
                sequence_NotExpression(context, (NotExpression) semanticObject);
                return;
            case StoexPackage.PARENTHESIS:
                sequence_Parenthesis(context, (Parenthesis) semanticObject);
                return;
            case StoexPackage.POWER_EXPRESSION:
                sequence_powExpr(context, (PowerExpression) semanticObject);
                return;
            case StoexPackage.PROBABILITY_FUNCTION_LITERAL:
                sequence_ProbabilityFunctionLiteral(context, (ProbabilityFunctionLiteral) semanticObject);
                return;
            case StoexPackage.PRODUCT_EXPRESSION:
                sequence_prodExpr(context, (ProductExpression) semanticObject);
                return;
            case StoexPackage.STRING_LITERAL:
                sequence_StringLiteral(context, (StringLiteral) semanticObject);
                return;
            case StoexPackage.TERM_EXPRESSION:
                sequence_sumExpr(context, (TermExpression) semanticObject);
                return;
            case StoexPackage.VARIABLE:
                sequence_Variable(context, (Variable) semanticObject);
                return;
            case StoexPackage.VARIABLE_REFERENCE:
                sequence_VariableReference(context, (VariableReference) semanticObject);
                return;
            }
        else if (semanticObject.eClass().getEPackage() == UnitsPackage.eINSTANCE)
            switch (semanticObject.eClass().getClassifierID()) {
            case UnitsPackage.BASE_UNIT:
                sequence_BaseUnit(context, (BaseUnit) semanticObject);
                return;
            case UnitsPackage.UNIT_DIVISION:
                sequence_unitDiv(context, (UnitDivision) semanticObject);
                return;
            case UnitsPackage.UNIT_MULTIPLICATION:
                sequence_unitMulti(context, (UnitMultiplication) semanticObject);
                return;
            case UnitsPackage.UNIT_POWER:
                sequence_unitPow(context, (UnitPower) semanticObject);
                return;
            }
        if (errorAcceptor != null)
            errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
    }

    /**
     * Constraint: name=UnitNames
     */
    protected void sequence_BaseUnit(EObject context, BaseUnit semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject, UnitsPackage.Literals.BASE_UNIT__NAME) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        UnitsPackage.Literals.BASE_UNIT__NAME));
        }
        INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
        feeder.accept(grammarAccess.getBaseUnitAccess().getNameUnitNamesEnumRuleCall_0(), semanticObject.getName());
        feeder.finish();
    }

    /**
     * Constraint: value=BOOLEAN_KEYWORDS
     */
    protected void sequence_BoolLiteral(EObject context, BoolLiteral semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject, StoexPackage.Literals.BOOL_LITERAL__VALUE) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        StoexPackage.Literals.BOOL_LITERAL__VALUE));
        }
        INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
        feeder.accept(grammarAccess.getBoolLiteralAccess().getValueBOOLEAN_KEYWORDSTerminalRuleCall_0(),
                semanticObject.isValue());
        feeder.finish();
    }

    /**
     * Constraint: ( (left=BooleanExpression_BooleanOperatorExpression_1_0
     * operation=BooleanOperations right=boolOrExpr) |
     * (left=boolOrExpr_BooleanOperatorExpression_1_0 operation=oroperations right=compareExpr) )
     */
    protected void sequence_BooleanExpression_boolOrExpr(EObject context, BooleanOperatorExpression semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (samples+=real_pdf_sample+ unit=Unit?)
     */
    protected void sequence_BoxedPDF(EObject context, BoxedPDF semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (value=DOUBLE unit=Unit?)
     */
    protected void sequence_DoubleLiteral(EObject context, DoubleLiteral semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (id=ID (parameters_FunctionLiteral+=boolAndExpr
     * parameters_FunctionLiteral+=boolAndExpr*)?)
     */
    protected void sequence_FunctionLiteral(EObject context, FunctionLiteral semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (value=DECINT unit=Unit?)
     */
    protected void sequence_IntLiteral(EObject context, IntLiteral semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (referenceName=ID innerReference_NamespaceReference=AbstractNamedReference)
     */
    protected void sequence_NamespaceReference(EObject context, NamespaceReference semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject,
                    StoexPackage.Literals.ABSTRACT_NAMED_REFERENCE__REFERENCE_NAME) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        StoexPackage.Literals.ABSTRACT_NAMED_REFERENCE__REFERENCE_NAME));
            if (transientValues.isValueTransient(semanticObject,
                    StoexPackage.Literals.NAMESPACE_REFERENCE__INNER_REFERENCE_NAMESPACE_REFERENCE) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        StoexPackage.Literals.NAMESPACE_REFERENCE__INNER_REFERENCE_NAMESPACE_REFERENCE));
        }
        INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
        feeder.accept(grammarAccess.getNamespaceReferenceAccess().getReferenceNameIDTerminalRuleCall_0_0(),
                semanticObject.getReferenceName());
        feeder.accept(grammarAccess.getNamespaceReferenceAccess()
                .getInnerReference_NamespaceReferenceAbstractNamedReferenceParserRuleCall_2_0(), semanticObject
                .getInnerReference_NamespaceReference());
        feeder.finish();
    }

    /**
     * Constraint: inner=unaryExpr
     */
    protected void sequence_NegativeExpression(EObject context, NegativeExpression semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject, StoexPackage.Literals.NEGATIVE_EXPRESSION__INNER) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        StoexPackage.Literals.NEGATIVE_EXPRESSION__INNER));
        }
        INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
        feeder.accept(grammarAccess.getNegativeExpressionAccess().getInnerUnaryExprParserRuleCall_1_0(),
                semanticObject.getInner());
        feeder.finish();
    }

    /**
     * Constraint: inner=unaryExpr
     */
    protected void sequence_NotExpression(EObject context, NotExpression semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject, StoexPackage.Literals.NOT_EXPRESSION__INNER) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        StoexPackage.Literals.NOT_EXPRESSION__INNER));
        }
        INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
        feeder.accept(grammarAccess.getNotExpressionAccess().getInnerUnaryExprParserRuleCall_1_0(),
                semanticObject.getInner());
        feeder.finish();
    }

    /**
     * Constraint: innerExpression=ifelseExpr
     */
    protected void sequence_Parenthesis(EObject context, Parenthesis semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject, StoexPackage.Literals.PARENTHESIS__INNER_EXPRESSION) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        StoexPackage.Literals.PARENTHESIS__INNER_EXPRESSION));
        }
        INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
        feeder.accept(grammarAccess.getParenthesisAccess().getInnerExpressionIfelseExprParserRuleCall_1_0(),
                semanticObject.getInnerExpression());
        feeder.finish();
    }

    /**
     * Constraint: function_ProbabilityFunctionLiteral=definition
     */
    protected void sequence_ProbabilityFunctionLiteral(EObject context, ProbabilityFunctionLiteral semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject,
                    StoexPackage.Literals.PROBABILITY_FUNCTION_LITERAL__FUNCTION_PROBABILITY_FUNCTION_LITERAL) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        StoexPackage.Literals.PROBABILITY_FUNCTION_LITERAL__FUNCTION_PROBABILITY_FUNCTION_LITERAL));
        }
        INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
        feeder.accept(grammarAccess.getProbabilityFunctionLiteralAccess()
                .getFunction_ProbabilityFunctionLiteralDefinitionParserRuleCall_0(), semanticObject
                .getFunction_ProbabilityFunctionLiteral());
        feeder.finish();
    }

    /**
     * Constraint: ( (samples+=numeric_int_sample+ unit=Unit?) | (samples+=numeric_real_sample+
     * unit=Unit?) | (orderedDomain?=ORDERED_DEF? samples+=stringsample+) |
     * (orderedDomain?=ORDERED_DEF? samples+=boolsample+) )
     */
    protected void sequence_ProbabilityMassFunction(EObject context, ProbabilityMassFunction semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: value=STRING
     */
    protected void sequence_StringLiteral(EObject context, StringLiteral semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject, StoexPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        StoexPackage.Literals.STRING_LITERAL__VALUE));
        }
        INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
        feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_0(),
                semanticObject.getValue());
        feeder.finish();
    }

    /**
     * Constraint: referenceName=ID
     */
    protected void sequence_VariableReference(EObject context, VariableReference semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject,
                    StoexPackage.Literals.ABSTRACT_NAMED_REFERENCE__REFERENCE_NAME) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        StoexPackage.Literals.ABSTRACT_NAMED_REFERENCE__REFERENCE_NAME));
        }
        INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
        feeder.accept(grammarAccess.getVariableReferenceAccess().getReferenceNameIDTerminalRuleCall_0(),
                semanticObject.getReferenceName());
        feeder.finish();
    }

    /**
     * Constraint: id_Variable=AbstractNamedReference
     */
    protected void sequence_Variable(EObject context, Variable semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject, StoexPackage.Literals.VARIABLE__ID_VARIABLE) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        StoexPackage.Literals.VARIABLE__ID_VARIABLE));
        }
        INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
        feeder.accept(grammarAccess.getVariableAccess().getId_VariableAbstractNamedReferenceParserRuleCall_0(),
                semanticObject.getId_Variable());
        feeder.finish();
    }

    /**
     * Constraint: ( (left=boolAndExpr_BooleanOperatorExpression_1_0 operation=andoperation
     * right=boolOrExpr) | (left=boolOrExpr_BooleanOperatorExpression_1_0 operation=oroperations
     * right=compareExpr) )
     */
    protected void sequence_boolAndExpr_boolOrExpr(EObject context, BooleanOperatorExpression semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (left=boolOrExpr_BooleanOperatorExpression_1_0 operation=oroperations
     * right=compareExpr)
     */
    protected void sequence_boolOrExpr(EObject context, BooleanOperatorExpression semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject,
                    StoexPackage.Literals.BOOLEAN_OPERATOR_EXPRESSION__LEFT) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        StoexPackage.Literals.BOOLEAN_OPERATOR_EXPRESSION__LEFT));
            if (transientValues.isValueTransient(semanticObject,
                    StoexPackage.Literals.BOOLEAN_OPERATOR_EXPRESSION__RIGHT) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        StoexPackage.Literals.BOOLEAN_OPERATOR_EXPRESSION__RIGHT));
            if (transientValues.isValueTransient(semanticObject,
                    StoexPackage.Literals.BOOLEAN_OPERATOR_EXPRESSION__OPERATION) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        StoexPackage.Literals.BOOLEAN_OPERATOR_EXPRESSION__OPERATION));
        }
        INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
        feeder.accept(grammarAccess.getBoolOrExprAccess().getBooleanOperatorExpressionLeftAction_1_0(),
                semanticObject.getLeft());
        feeder.accept(grammarAccess.getBoolOrExprAccess().getOperationOroperationsEnumRuleCall_1_1_0(),
                semanticObject.getOperation());
        feeder.accept(grammarAccess.getBoolOrExprAccess().getRightCompareExprParserRuleCall_1_2_0(),
                semanticObject.getRight());
        feeder.finish();
    }

    /**
     * Constraint: (value=BOOLEAN_KEYWORDS probability=DOUBLE)
     */
    protected void sequence_boolsample(EObject context, BoolSample semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject, ProbfunctionPackage.Literals.SAMPLE__PROBABILITY) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        ProbfunctionPackage.Literals.SAMPLE__PROBABILITY));
            if (transientValues.isValueTransient(semanticObject, ProbfunctionPackage.Literals.SAMPLE__VALUE) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        ProbfunctionPackage.Literals.SAMPLE__VALUE));
        }
        INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
        feeder.accept(grammarAccess.getBoolsampleAccess().getValueBOOLEAN_KEYWORDSTerminalRuleCall_1_0(),
                semanticObject.getValue());
        feeder.accept(grammarAccess.getBoolsampleAccess().getProbabilityDOUBLETerminalRuleCall_3_0(),
                semanticObject.getProbability());
        feeder.finish();
    }

    /**
     * Constraint: (left=compareExpr_CompareExpression_1_0 operation=CompareOperations
     * right=sumExpr)
     */
    protected void sequence_compareExpr(EObject context, CompareExpression semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject, StoexPackage.Literals.COMPARE_EXPRESSION__LEFT) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        StoexPackage.Literals.COMPARE_EXPRESSION__LEFT));
            if (transientValues.isValueTransient(semanticObject, StoexPackage.Literals.COMPARE_EXPRESSION__RIGHT) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        StoexPackage.Literals.COMPARE_EXPRESSION__RIGHT));
            if (transientValues.isValueTransient(semanticObject, StoexPackage.Literals.COMPARE_EXPRESSION__OPERATION) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        StoexPackage.Literals.COMPARE_EXPRESSION__OPERATION));
        }
        INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
        feeder.accept(grammarAccess.getCompareExprAccess().getCompareExpressionLeftAction_1_0(),
                semanticObject.getLeft());
        feeder.accept(grammarAccess.getCompareExprAccess().getOperationCompareOperationsEnumRuleCall_1_1_0(),
                semanticObject.getOperation());
        feeder.accept(grammarAccess.getCompareExprAccess().getRightSumExprParserRuleCall_1_2_0(),
                semanticObject.getRight());
        feeder.finish();
    }

    /**
     * Constraint: (conditionExpression=ifelseExpr_IfElseExpression_1_0 ifExpression=boolAndExpr
     * elseExpression=boolAndExpr)
     */
    protected void sequence_ifelseExpr(EObject context, IfElseExpression semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject,
                    StoexPackage.Literals.IF_ELSE_EXPRESSION__IF_EXPRESSION) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        StoexPackage.Literals.IF_ELSE_EXPRESSION__IF_EXPRESSION));
            if (transientValues.isValueTransient(semanticObject,
                    StoexPackage.Literals.IF_ELSE_EXPRESSION__ELSE_EXPRESSION) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        StoexPackage.Literals.IF_ELSE_EXPRESSION__ELSE_EXPRESSION));
            if (transientValues.isValueTransient(semanticObject,
                    StoexPackage.Literals.IF_ELSE_EXPRESSION__CONDITION_EXPRESSION) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        StoexPackage.Literals.IF_ELSE_EXPRESSION__CONDITION_EXPRESSION));
        }
        INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
        feeder.accept(grammarAccess.getIfelseExprAccess().getIfElseExpressionConditionExpressionAction_1_0(),
                semanticObject.getConditionExpression());
        feeder.accept(grammarAccess.getIfelseExprAccess().getIfExpressionBoolAndExprParserRuleCall_1_2_0(),
                semanticObject.getIfExpression());
        feeder.accept(grammarAccess.getIfelseExprAccess().getElseExpressionBoolAndExprParserRuleCall_1_4_0(),
                semanticObject.getElseExpression());
        feeder.finish();
    }

    /**
     * Constraint: (value=SIGNED_INT probability=DOUBLE)
     */
    protected void sequence_numeric_int_sample(EObject context, IntSample semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject, ProbfunctionPackage.Literals.SAMPLE__PROBABILITY) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        ProbfunctionPackage.Literals.SAMPLE__PROBABILITY));
            if (transientValues.isValueTransient(semanticObject, ProbfunctionPackage.Literals.SAMPLE__VALUE) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        ProbfunctionPackage.Literals.SAMPLE__VALUE));
        }
        INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
        feeder.accept(grammarAccess.getNumeric_int_sampleAccess().getValueSIGNED_INTParserRuleCall_1_0(),
                semanticObject.getValue());
        feeder.accept(grammarAccess.getNumeric_int_sampleAccess().getProbabilityDOUBLETerminalRuleCall_3_0(),
                semanticObject.getProbability());
        feeder.finish();
    }

    /**
     * Constraint: (value=SIGNED_NUMBER probability=DOUBLE)
     */
    protected void sequence_numeric_real_sample(EObject context, DoubleSample semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject, ProbfunctionPackage.Literals.SAMPLE__PROBABILITY) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        ProbfunctionPackage.Literals.SAMPLE__PROBABILITY));
            if (transientValues.isValueTransient(semanticObject, ProbfunctionPackage.Literals.SAMPLE__VALUE) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        ProbfunctionPackage.Literals.SAMPLE__VALUE));
        }
        INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
        feeder.accept(grammarAccess.getNumeric_real_sampleAccess().getValueSIGNED_NUMBERParserRuleCall_1_0(),
                semanticObject.getValue());
        feeder.accept(grammarAccess.getNumeric_real_sampleAccess().getProbabilityDOUBLETerminalRuleCall_3_0(),
                semanticObject.getProbability());
        feeder.finish();
    }

    /**
     * Constraint: (base=powExpr_PowerExpression_1_0 exponent=unaryExpr)
     */
    protected void sequence_powExpr(EObject context, PowerExpression semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject, StoexPackage.Literals.POWER_EXPRESSION__BASE) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        StoexPackage.Literals.POWER_EXPRESSION__BASE));
            if (transientValues.isValueTransient(semanticObject, StoexPackage.Literals.POWER_EXPRESSION__EXPONENT) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        StoexPackage.Literals.POWER_EXPRESSION__EXPONENT));
        }
        INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
        feeder.accept(grammarAccess.getPowExprAccess().getPowerExpressionBaseAction_1_0(), semanticObject.getBase());
        feeder.accept(grammarAccess.getPowExprAccess().getExponentUnaryExprParserRuleCall_1_2_0(),
                semanticObject.getExponent());
        feeder.finish();
    }

    /**
     * Constraint: (left=prodExpr_ProductExpression_1_0 operation=ProductOperations right=powExpr)
     */
    protected void sequence_prodExpr(EObject context, ProductExpression semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject, StoexPackage.Literals.PRODUCT_EXPRESSION__LEFT) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        StoexPackage.Literals.PRODUCT_EXPRESSION__LEFT));
            if (transientValues.isValueTransient(semanticObject, StoexPackage.Literals.PRODUCT_EXPRESSION__RIGHT) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        StoexPackage.Literals.PRODUCT_EXPRESSION__RIGHT));
            if (transientValues.isValueTransient(semanticObject, StoexPackage.Literals.PRODUCT_EXPRESSION__OPERATION) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        StoexPackage.Literals.PRODUCT_EXPRESSION__OPERATION));
        }
        INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
        feeder.accept(grammarAccess.getProdExprAccess().getProductExpressionLeftAction_1_0(), semanticObject.getLeft());
        feeder.accept(grammarAccess.getProdExprAccess().getOperationProductOperationsEnumRuleCall_1_1_0(),
                semanticObject.getOperation());
        feeder.accept(grammarAccess.getProdExprAccess().getRightPowExprParserRuleCall_1_2_0(),
                semanticObject.getRight());
        feeder.finish();
    }

    /**
     * Constraint: (value=SIGNED_NUMBER probability=DOUBLE)
     */
    protected void sequence_real_pdf_sample(EObject context, ContinuousSample semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject, ProbfunctionPackage.Literals.CONTINUOUS_SAMPLE__VALUE) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        ProbfunctionPackage.Literals.CONTINUOUS_SAMPLE__VALUE));
            if (transientValues.isValueTransient(semanticObject,
                    ProbfunctionPackage.Literals.CONTINUOUS_SAMPLE__PROBABILITY) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        ProbfunctionPackage.Literals.CONTINUOUS_SAMPLE__PROBABILITY));
        }
        INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
        feeder.accept(grammarAccess.getReal_pdf_sampleAccess().getValueSIGNED_NUMBERParserRuleCall_1_0(),
                semanticObject.getValue());
        feeder.accept(grammarAccess.getReal_pdf_sampleAccess().getProbabilityDOUBLETerminalRuleCall_3_0(),
                semanticObject.getProbability());
        feeder.finish();
    }

    /**
     * Constraint: (value=STRING probability=DOUBLE)
     */
    protected void sequence_stringsample(EObject context, StringSample semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject, ProbfunctionPackage.Literals.SAMPLE__PROBABILITY) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        ProbfunctionPackage.Literals.SAMPLE__PROBABILITY));
            if (transientValues.isValueTransient(semanticObject, ProbfunctionPackage.Literals.SAMPLE__VALUE) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        ProbfunctionPackage.Literals.SAMPLE__VALUE));
        }
        INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
        feeder.accept(grammarAccess.getStringsampleAccess().getValueSTRINGTerminalRuleCall_1_0(),
                semanticObject.getValue());
        feeder.accept(grammarAccess.getStringsampleAccess().getProbabilityDOUBLETerminalRuleCall_3_0(),
                semanticObject.getProbability());
        feeder.finish();
    }

    /**
     * Constraint: (left=sumExpr_TermExpression_1_0 operation=TermOperations right=prodExpr)
     */
    protected void sequence_sumExpr(EObject context, TermExpression semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject, StoexPackage.Literals.TERM_EXPRESSION__LEFT) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        StoexPackage.Literals.TERM_EXPRESSION__LEFT));
            if (transientValues.isValueTransient(semanticObject, StoexPackage.Literals.TERM_EXPRESSION__RIGHT) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        StoexPackage.Literals.TERM_EXPRESSION__RIGHT));
            if (transientValues.isValueTransient(semanticObject, StoexPackage.Literals.TERM_EXPRESSION__OPERATION) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        StoexPackage.Literals.TERM_EXPRESSION__OPERATION));
        }
        INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
        feeder.accept(grammarAccess.getSumExprAccess().getTermExpressionLeftAction_1_0(), semanticObject.getLeft());
        feeder.accept(grammarAccess.getSumExprAccess().getOperationTermOperationsEnumRuleCall_1_1_0(),
                semanticObject.getOperation());
        feeder.accept(grammarAccess.getSumExprAccess().getRightProdExprParserRuleCall_1_2_0(),
                semanticObject.getRight());
        feeder.finish();
    }

    /**
     * Constraint: (dividend=unitDiv_UnitDivision_1_0 divisor=Unit)
     */
    protected void sequence_unitDiv(EObject context, UnitDivision semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject, UnitsPackage.Literals.UNIT_DIVISION__DIVIDEND) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        UnitsPackage.Literals.UNIT_DIVISION__DIVIDEND));
            if (transientValues.isValueTransient(semanticObject, UnitsPackage.Literals.UNIT_DIVISION__DIVISOR) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        UnitsPackage.Literals.UNIT_DIVISION__DIVISOR));
        }
        INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
        feeder.accept(grammarAccess.getUnitDivAccess().getUnitDivisionDividendAction_1_0(),
                semanticObject.getDividend());
        feeder.accept(grammarAccess.getUnitDivAccess().getDivisorUnitParserRuleCall_1_2_0(),
                semanticObject.getDivisor());
        feeder.finish();
    }

    /**
     * Constraint: (units+=unitMulti_UnitMultiplication_1_0 units+=Unit)
     */
    protected void sequence_unitMulti(EObject context, UnitMultiplication semanticObject) {
        genericSequencer.createSequence(context, semanticObject);
    }

    /**
     * Constraint: (unit=unitPow_UnitPower_1_0 exponent=SIGNED_INT)
     */
    protected void sequence_unitPow(EObject context, UnitPower semanticObject) {
        if (errorAcceptor != null) {
            if (transientValues.isValueTransient(semanticObject, UnitsPackage.Literals.UNIT_POWER__UNIT) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        UnitsPackage.Literals.UNIT_POWER__UNIT));
            if (transientValues.isValueTransient(semanticObject, UnitsPackage.Literals.UNIT_POWER__EXPONENT) == ValueTransient.YES)
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,
                        UnitsPackage.Literals.UNIT_POWER__EXPONENT));
        }
        INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
        SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
        feeder.accept(grammarAccess.getUnitPowAccess().getUnitPowerUnitAction_1_0(), semanticObject.getUnit());
        feeder.accept(grammarAccess.getUnitPowAccess().getExponentSIGNED_INTParserRuleCall_1_2_0(),
                semanticObject.getExponent());
        feeder.finish();
    }
}
