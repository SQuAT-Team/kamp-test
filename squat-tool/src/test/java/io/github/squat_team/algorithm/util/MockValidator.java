package io.github.squat_team.algorithm.util;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import io.github.squat_team.AbstractPCMBot;
import io.github.squat_team.model.PCMArchitectureInstance;
import io.github.squat_team.model.PCMScenarioResult;

/**
 * Helps to validate that all results for mocked bots are set correctly. Use
 * {@link #validate(int, int, int)} to start the test.
 */
public class MockValidator {
	private List<AbstractPCMBot> bots;
	private PCMArchitectureInstance initialArchitecture;
	private int maxLevel = -1;
	private int minWidth = -1;
	private int maxWidth = -1;

	/**
	 * Initiates a new validator
	 * 
	 * @param bots
	 *            all bots that are used in the test
	 * @param initialArchitecture
	 *            the initial architecture for the test
	 */
	public MockValidator(List<AbstractPCMBot> bots, PCMArchitectureInstance initialArchitecture) {
		this.bots = bots;
		this.initialArchitecture = initialArchitecture;
	}

	/**
	 * The validator will check that all bots are able to optimize the initial
	 * architecture and its children for a given number of levels. It will also make
	 * sure that each optimization operation finds enough candidates. In addition it
	 * checks that all bots are able to analyze every result. The method will throw
	 * a {@link RuntimeException} if the validation fails.
	 * 
	 * @param maxLevel
	 *            the number of levels (of search) that should be mocked for each
	 *            bot.
	 * @param minWidth
	 *            the minimal threshold for generated candidates in each
	 *            optimization.
	 * @param maxWidth
	 *            the maximum threshold for generated candidates in each
	 *            optimization.
	 */
	public void validate(int maxLevel, int minWidth, int maxWidth) {
		this.maxLevel = maxLevel;
		this.minWidth = minWidth;
		this.maxWidth = maxWidth;

		for (AbstractPCMBot bot : bots) {
			validate(bot);
		}
	}

	/**
	 * Validates exactly one bot.
	 * 
	 * @param bot
	 *            the bot to validate.
	 */
	private void validate(AbstractPCMBot bot) {
		Map<Integer, Set<PCMArchitectureInstance>> levelResults = initializeResultsPerLevel(maxLevel);
		for (int level = 1; level < maxLevel + 2; level++) {
			validateLevel(level, bot, levelResults);
		}
		checkAdditionalLevel(levelResults);
	}

	/**
	 * Validates one level of search for one bot.
	 * 
	 * @param level
	 * @param bot
	 * @param levelResults
	 *            contains the found candidates related to the level of search.
	 */
	private void validateLevel(int level, AbstractPCMBot bot, Map<Integer, Set<PCMArchitectureInstance>> levelResults) {
		Set<PCMArchitectureInstance> previousLevelResults = levelResults.get(level - 1);
		Set<PCMArchitectureInstance> currentLevelResults = levelResults.get(level);
		for (PCMArchitectureInstance parentArchitecture : previousLevelResults) {
			List<PCMScenarioResult> childResults = bot.searchForAlternatives(parentArchitecture);
			Set<PCMArchitectureInstance> architectures = extractArchitectures(childResults);
			currentLevelResults.addAll(architectures);
			checkOptimizationResponses(level, bot, parentArchitecture, childResults, architectures);
		}
		checkBotResponses(currentLevelResults);
	}

	/**
	 * Validates the optimization generated by one bot in one level from a
	 * particular previous result
	 * 
	 * @param level
	 *            the level of search the bot found the results
	 * @param bot
	 *            the bot that found the results
	 * @param parentArchitecture
	 *            the architecture that has been optimized
	 * @param results
	 *            the results found by the bot
	 * @param architectures
	 *            the (optimized) architectures - same as the ones in the results
	 */
	private void checkOptimizationResponses(int level, AbstractPCMBot bot, PCMArchitectureInstance parentArchitecture,
			List<PCMScenarioResult> results, Set<PCMArchitectureInstance> architectures) {
		if (level <= maxLevel) {
			boolean resultsValid = checkValid(results);
			boolean sizeMinOk = checkMinSize(architectures);
			boolean sizeMaxOk = checkMaxSize(architectures);
			if (!resultsValid) {
				throw new RuntimeException("Optimization results from " + bot + " for " + parentArchitecture
						+ " in level " + level + " are not completely mocked.");
			}
			if (!sizeMinOk) {
				throw new RuntimeException("The number of results returned by " + bot + " for " + parentArchitecture
						+ " in level " + level + " is smaller than " + minWidth);
			}
			if (!sizeMaxOk) {
				throw new RuntimeException("The number of results returned by " + bot + " for " + parentArchitecture
						+ " in level " + level + " is bigger than " + maxWidth);
			}
		}
	}

	/**
	 * Fills a map with a set for each level plus one for the initial architecture
	 * and one for an additional level.
	 * 
	 * @param maxLevel
	 *            the number of levels of search that are mocked
	 * @return the map - associates the level and the results
	 */
	private Map<Integer, Set<PCMArchitectureInstance>> initializeResultsPerLevel(int maxLevel) {
		Map<Integer, Set<PCMArchitectureInstance>> levelResults = new HashMap<>();
		for (int i = 0; i < maxLevel + 2; i++) {
			levelResults.put(i, new HashSet<>());
		}
		levelResults.get(0).add(initialArchitecture);
		return levelResults;
	}

	/**
	 * Checks the results for the level after {@link #maxLevel}. There should be no
	 * additional results.
	 * 
	 * @param levelResults
	 *            the found results in the associated level.
	 */
	private void checkAdditionalLevel(Map<Integer, Set<PCMArchitectureInstance>> levelResults) {
		Set<PCMArchitectureInstance> additionalLevel = levelResults.get(maxLevel + 1);
		boolean moreLevels = containsNewCandidates(additionalLevel);
		if (moreLevels) {
			throw new RuntimeException("Too many levels mocked. Should be empty: " + additionalLevel);
		}
	}

	/**
	 * Checks whether the results contain new candidates.
	 * 
	 * @param levelResults
	 * @return
	 */
	private boolean containsNewCandidates(Set<PCMArchitectureInstance> levelResults) {
		return !((levelResults.isEmpty()) || (levelResults.size() == 1 && levelResults.contains(null)));
	}

	/**
	 * Validates all responses. Assures that all bots can analyze these results.
	 * 
	 * @param architectures
	 *            the candidates that should be checked.
	 */
	private void checkBotResponses(Set<PCMArchitectureInstance> architectures) {
		for (PCMArchitectureInstance architecture : architectures) {
			checkBotResponses(architecture);
		}
	}

	/**
	 * Validates a response. Assures that all bots can analyze this candidate.
	 * 
	 * @param architecture
	 *            the candidate that should be checked.
	 */
	private void checkBotResponses(PCMArchitectureInstance architecture) {
		boolean valid = true;
		for (AbstractPCMBot bot : bots) {
			valid = valid && checkValid(bot.analyze(architecture));
			valid = valid && checkValid(bot.analyze(architecture, null));
			valid = valid && checkValid(bot.analyze(architecture, ""));
			if (!valid) {
				throw new RuntimeException("Bot " + bot + " can not analyze architecture " + architecture);
			}
		}
	}

	/**
	 * Checks whether there are enough results.
	 * 
	 * @param architectures
	 * @return true if the size is ok.
	 */
	private boolean checkMinSize(Set<PCMArchitectureInstance> architectures) {
		return architectures.size() >= minWidth;
	}

	/**
	 * Checks whether there are not too many results.
	 * 
	 * @param architectures
	 * @return true if the size is ok.
	 */
	private boolean checkMaxSize(Set<PCMArchitectureInstance> architectures) {
		return architectures.size() <= maxWidth;
	}

	/**
	 * Gets all architectures that are carried by the results.
	 * 
	 * @param results
	 * @return
	 */
	private Set<PCMArchitectureInstance> extractArchitectures(List<PCMScenarioResult> results) {
		Set<PCMArchitectureInstance> architectures = new HashSet<>();
		for (PCMScenarioResult result : results) {
			architectures.add(result.getResultingArchitecture());
		}
		return architectures;
	}

	/**
	 * Checks that the results are valid. This means that the critical values
	 * (architecture, response, parent) are set.
	 * 
	 * @param results
	 * @return
	 */
	private boolean checkValid(List<PCMScenarioResult> results) {
		boolean valid = true;
		for (PCMScenarioResult result : results) {
			valid = valid && checkValid(result);
		}
		return valid;
	}

	/**
	 * Checks that the result is valid. This means that the critical values
	 * (architecture, response, parent) are set.
	 * 
	 * @param result
	 * @return
	 */
	private boolean checkValid(PCMScenarioResult result) {
		boolean hasArchitecture = result.getResultingArchitecture() != null;
		boolean hasParent = result.getOriginatingBot() != null;
		boolean hasResponse = result.getResult().getResponse() != null;
		return hasArchitecture && hasParent && hasResponse;
	}

}
